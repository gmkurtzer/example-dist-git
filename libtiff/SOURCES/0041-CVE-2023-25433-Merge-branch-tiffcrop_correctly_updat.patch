From 83f6ae4cce52cd4feaebf2bc4fc2d5077a10677c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Matej=20Mu=C5=BEila?= <mmuzila@redhat.com>
Date: Thu, 16 May 2024 14:43:44 +0200
Subject: [PATCH] (CVE-2023-25433) Merge branch
 'tiffcrop_correctly_update_buffersize_after_rotate_fix#520' into 'master'

tiffcrop correctly update buffersize after rotateImage() fix#520

Closes #520

See merge request libtiff/libtiff!467

(cherry picked from commit 6366e8f776a0fa0dd476d37b108eecdf42b950f3)
---
 tools/tiffcrop.c | 72 ++++++++++++++++++++++++++++++++++++++----------
 1 file changed, 58 insertions(+), 14 deletions(-)

diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
index 77923cf3..8b761874 100644
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -529,7 +529,7 @@ static int rotateContigSamples24bits(uint16, uint16, uint16, uint32,
 static int rotateContigSamples32bits(uint16, uint16, uint16, uint32, 
                                      uint32,   uint32, uint8 *, uint8 *);
 static int rotateImage(uint16, struct image_data *, uint32 *, uint32 *,
- 		       unsigned char **);
+ 		       unsigned char **, tsize_t *);
 static int mirrorImage(uint16, uint16, uint16, uint32, uint32,
 		       unsigned char *);
 static int invertImage(uint16, uint16, uint16, uint32, uint32,
@@ -6358,7 +6358,7 @@ static int  correct_orientation(struct image_data *image, unsigned char **work_b
       return (-1);
       }
  
-    if (rotateImage(rotation, image, &image->width, &image->length, work_buff_ptr))
+    if (rotateImage(rotation, image, &image->width, &image->length, work_buff_ptr, NULL))
       {
       TIFFError ("correct_orientation", "Unable to rotate image");
       return (-1);
@@ -7578,16 +7578,20 @@ processCropSelections(struct image_data *image, struct crop_mask *crop,
 
     if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */
       {
+      /* rotateImage() set up a new buffer and calculates its size
+       * individually. Therefore, seg_buffs size  needs to be updated
+       * accordingly. */
+
+      tsize_t rot_buf_size = 0;
       if (rotateImage(crop->rotation, image, &crop->combined_width, 
-                      &crop->combined_length, &crop_buff))
+                      &crop->combined_length, &crop_buff, &rot_buf_size))
         {
         TIFFError("processCropSelections", 
                   "Failed to rotate composite regions by %d degrees", crop->rotation);
         return (-1);
         }
       seg_buffs[0].buffer = crop_buff;
-      seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)
-                            * image->spp) * crop->combined_length; 
+      seg_buffs[0].size = rot_buf_size;
       }
     }
   else  /* Separated Images */
@@ -7684,8 +7688,18 @@ processCropSelections(struct image_data *image, struct crop_mask *crop,
 
       if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */
         {
-	if (rotateImage(crop->rotation, image, &crop->regionlist[i].width, 
-			&crop->regionlist[i].length, &crop_buff))
+        /* rotateImage() changes image->width, ->length, ->xres and
+         * ->yres, what it schouldn't do here, when more than one
+         * section is processed. ToDo: Therefore rotateImage() and its
+         * usage has to be reworked (e.g. like mirrorImage()) !!
+         * Furthermore, rotateImage() set up a new buffer and calculates
+         * its size individually. Therefore, seg_buffs size  needs to be
+         * updated accordingly. */
+          tsize_t rot_buf_size = 0;
+          if (rotateImage(
+                      crop->rotation, image, &crop->regionlist[i].width,
+                      &crop->regionlist[i].length, &crop_buff, &rot_buf_size))
+
           {
           TIFFError("processCropSelections", 
                     "Failed to rotate crop region by %d degrees", crop->rotation);
@@ -7696,8 +7710,7 @@ processCropSelections(struct image_data *image, struct crop_mask *crop,
         crop->combined_width = total_width;
         crop->combined_length = total_length;
         seg_buffs[i].buffer = crop_buff;
-        seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)
-                               * image->spp) * crop->regionlist[i].length; 
+        seg_buffs[i].size = rot_buf_size;
         }
       }
     }
@@ -7813,7 +7826,7 @@ createCroppedImage(struct image_data *image, struct crop_mask *crop,
   if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */
     {
     if (rotateImage(crop->rotation, image, &crop->combined_width, 
-                    &crop->combined_length, crop_buff_ptr))
+                    &crop->combined_length, crop_buff_ptr, NULL))
       {
       TIFFError("createCroppedImage", 
                 "Failed to rotate image or cropped selection by %d degrees", crop->rotation);
@@ -8476,13 +8489,14 @@ rotateContigSamples32bits(uint16 rotation, uint16 spp, uint16 bps, uint32 width,
 /* Rotate an image by a multiple of 90 degrees clockwise */
 static int
 rotateImage(uint16 rotation, struct image_data *image, uint32 *img_width, 
-            uint32 *img_length, unsigned char **ibuff_ptr)
+            uint32 *img_length, unsigned char **ibuff_ptr, tsize_t *rot_buf_size)
   {
   int      shift_width;
   uint32   bytes_per_pixel, bytes_per_sample;
   uint32   row, rowsize, src_offset, dst_offset;
   uint32   i, col, width, length;
-  uint32   colsize, buffsize, col_offset, pix_offset;
+  uint32   colsize,  col_offset, pix_offset;
+  tmsize_t buffsize;
   unsigned char *ibuff;
   unsigned char *src;
   unsigned char *dst;
@@ -8495,12 +8509,40 @@ rotateImage(uint16 rotation, struct image_data *image, uint32 *img_width,
   spp = image->spp;
   bps = image->bps;
 
+  if ((spp != 0 && bps != 0 &&
+       width > (uint32)((UINT32_MAX - 7) / spp / bps)) ||
+      (spp != 0 && bps != 0 &&
+       length > (uint32)((UINT32_MAX - 7) / spp / bps)))
+  {
+      TIFFError("rotateImage", "Integer overflow detected.");
+      return (-1);
+  }
   rowsize = ((bps * spp * width) + 7) / 8;
   colsize = ((bps * spp * length) + 7) / 8;
   if ((colsize * width) > (rowsize * length))
-    buffsize = (colsize + 1) * width;
+  {
+      if (((tmsize_t)colsize + 1) != 0 &&
+          (tmsize_t)width > ((TIFF_TMSIZE_T_MAX - 3) /
+                             ((tmsize_t)colsize + 1)))
+      {
+          TIFFError("rotateImage",
+                    "Integer overflow when calculating buffer size.");
+          return (-1);
+      }
+      buffsize = ((tmsize_t)colsize + 1) * width;
+  }
   else
-    buffsize = (rowsize + 1) * length;
+  {
+      if (((tmsize_t)rowsize + 1) != 0 &&
+          (tmsize_t)length > ((TIFF_TMSIZE_T_MAX - 3) /
+                              ((tmsize_t)rowsize + 1)))
+      {
+          TIFFError("rotateImage",
+                    "Integer overflow when calculating buffer size.");
+          return (-1);
+      }
+      buffsize = (rowsize + 1) * length;
+  }
 
   bytes_per_sample = (bps + 7) / 8;
   bytes_per_pixel  = ((bps * spp) + 7) / 8;
@@ -8526,6 +8568,8 @@ rotateImage(uint16 rotation, struct image_data *image, uint32 *img_width,
     return (-1);
     }
   _TIFFmemset(rbuff, '\0', buffsize);
+  if (rot_buf_size != NULL)
+      *rot_buf_size = buffsize;
 
   ibuff = *ibuff_ptr;
   switch (rotation)
